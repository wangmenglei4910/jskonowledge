<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
          1.字符串的length只可读不可写
          字符串的方法基本上是不改变源字符串的
          2.字符串的截取
          substring(x,y)从哪里开始截取，到哪里结束不包括结束位置
          传一个值，截取到最后，传负值是从后往前截取
          substr(x,y)从那开始截取，截取几个
          slice同substring
          3.分割字符串split
          4.indexOf（指定字符，从第几位开始）
          比如是index（'x',3）的意思是从第三个字符开始往后找，第一个x的索引值，从0开始计算
          找到指定字符首次出现的位置，返回出来索引，
             找不到-1
          5.includes包含，字符串中是否包含指定字符，包含返回true，不包含返回false
          6.toUpperCase  把小写英文转成大写英文
          toLowerCase  把大写英文转成小写英文
          trim  去掉前后空格
定时器：（定时器一定要考虑怎样去关闭）
          连续炸：setInterval(函数,指定时间(毫秒),第一个函数的实参) 
            每间隔一段指定时间，就执行一次函数
            返回值为数字(即为定时器的编号)。

            清除定时器:
                clearInterval(编号)

        (炸一次)
        setTimeout(函数,指定时间(毫秒),第一个函数的实参)
            当到指定的时间时，只执行一次函数
            返回值为数字(即为定时器的编号)。

        clearTimeout(编号);清除定时器
递归：
            函数自己调用自己
            为什么要自己调用自己？
                一个函数里面有相应的运算或者是逻辑处理
                需要这个处理重复执行，所以才需要自己调用自己。
            
            注意:
                递归容易死循环，所以需要在写上递归中终止条件
递归求和：
        function fn(n){ 
            if(n===1) return 1;
            return fn(n-1)+n
        }
        fn();

sort对象排序 
 var  ary = [{age:1},{age:12},{age:13},{age:11},{age:21},{age:18}]
   let cur =ary.sort(function(a,b){
       return a.age-b.age
       
   });
   console.log(cur)

                   

        
        
        
        
        */
    </script>
  
</body>
</html>
