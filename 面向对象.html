<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
1.单例模式
      单例   单独的实例
      实例：把相同的事务总结（归纳，抽象）出来，形成一类事务，
      把描述事务的属性和方法具体化，这个具体的描述的对象就是实例
      变量：let a=20;
      属性：obj.a=20;
      函数：function  fn(){}
      方法：obj.fn=function(){}
    教师-->那么多职业中的一类职业（类）
    语文老师-->倪老师（实例）
    命名冲突：
        1.封闭空间
              把一段代码放到一个函数内，当执行函数的时候，函数内的域和外界是互不干扰的
        2.命名空间 
               把一些变量或者函数变成某个对象下的属性和方法，对象与对象之间空间地址是
               不一样的，所以可以解决命名冲突的问题。
单例模式的优势：
        1.解决命名冲突
        2.把相同的事务归为一类，并且把这些属性或者方法放到一个堆内存空间中储存。
        3.模块化的开发
2.高级单例模式
       单例模式功能相对单一，用来描述具体一个事务。
       让其复杂，那就需要高级单例模式
       使用一个匿名函数自执行函数，这个函数返回一个对象
       高级单例模式，可以实现低耦合，高内聚 
2.构造函数
       把属性或者方法挂在this上，然后去new这个函数
       潜规则是构造函数首字母大写
    new是一元运算符  -->专门运算函数的******
    一元运算符：符合两边只有一个操作数的符号就是一元运算符；主要有两种：“++”“--”
   1. 执行函数，不使用()调用也是可以执行的，此时的()只是为了传参
   2.构造函数(fn)中的this指向当前实例
        跟普通函数比较把默认的window转成当前实例
        构造函数function Fn(){}
        实例化对象fn{}
   3.return结果默认指向当前实例this
         有return如果后面跟的是一个基本数据类型，结果依然是实例
         如果后面跟的是一个引用类型，那么结果就是这个return后的引用类型。
   面向对象编程：
         把描述相同的事务抽象出来，归为一类，把描述这个类的属性和方法挂在这个类的原型（prototype）上的一种编程方式叫做面向对象。
   js的面向对象有特征：
         抽象：抽离出长得相像的部分
         封装
         继承
         多态 
    类-->构造函数-->把相同的代码抽离出来，归纳在一个函数中  
3.原型
         当定义一个函数的时候，这个函数自身有一些属性或者方法，其中有一个属性
         叫做prototype，这个属性叫做原型。
         只要是个函数，函数下都有一个叫prototype的属性，值为对象，这个
         原型下的方法或者属性只有2种方式可以获取：
         1.obj.prototype.xx()
         2.new obj().xx()
         实例化对象上的原型链===构造函数的原型
         对象.__proto__===函数.prototype
         对象上有原型链-->指向构造函数的原型
    所以说，函数即是函数，又是对象(它是Function的实例化对象)
        函数即有原型，也有原型链，函数的原型上的属性或者方法只给它的
        实例化对象使用。
         ****prototype是一个对象****
    他的用处是，如果实例化对象上没有某个属性或者方法，还会去这个实例化对象的构造函数
         的原型下去查找。（属性 obj.a  方法  obj.fn=function(){}）
         如果构造函数的原型上没有这个方法，那么还会去原型下的原型链（__proto__）中去查找
         找到object.prototype
****换言之： 构造韩叔叔的原型下的方法只给他的实例化对象使用
实例找链，函数找构造函数原型。


    使用原型的目的：
         当构造函数中添加方法的时候，每new一次就生成一个同类方法，这些方法虽然
         同类但是各自不相等，这就导致如果new若干次，那么就会生成若干个一模一样
         的方法，这样对性能是不友好的，所以我们要使用原型的方式把方法挂在原型上。


        
        
        
        
        
        
        
        
        
        */
    
    
    </script>
</body>
</html>