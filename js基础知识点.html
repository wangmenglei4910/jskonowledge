<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>

       /*
       函数：
       定义：
       （1）函数声明
        (2) 函数表达式
        （3）类声明 new Function
        1.函数调用：
       （1）函数名加小括号，fn()
        (2) 时间调用：一般是赋值一个匿名函数或者是赋值一个函数（名）地址
        （3）定时器调用；（使用定时器，一定想到怎么去关闭）
        setInterval(function(){},1000)
        setTimeout(function(){},1000)
        （4）匿名函数自执行(function(){})()
        当声明函数的时候，开辟了一个堆内存，把函数内的代码当作字符串存在堆内存中，
        最后把这个堆内存的地址，赋值给函数名或者变量中赋值，执行上下文直到变量销毁，
        整个函数就运行完成了

        在函数调用的时候，在函数内部开了一个执行栈，把函数中的字符串拷贝一份
        到执行栈执行，参数

        2.在定义函数的时候，自定义的参数名名叫做形参（形参当作变量来看）
        在调用的时候，括号里传的参数叫做实参（实实际际的）实参可以为所有数据类型
        实参参数与参数之间用逗号隔开，实参集合是arguments
        注意：形参是对应实参的，他们的顺序是一一对应的，中间没有实参，那么必须占位
        3.arguments是一个实参集合，类数组，可以通过下标获取某个实参
        4.函数返回值
        函数内的参数或者变量默认是不能被外界所访问的
        函数内如果没有某个变量或者参数，会去函数外查找，直到window结束

        当一个函数在调用（函数名+括号）的时候，做了两件事
        （1.）执行函数内的代码
        （2.）函数返回值
        默认（没有写return）的返回值为undefined
        通过return去设置函数返回值，return后面是什么，返回的结果是什么
        函数返回值的细节：
        return后会终止后面的代码执行，如果函数中使用循环，使用了return会终止循环
        如果有return，但是后面没有值，也是undefined和没有return返回值一样。
循环：
        for(let i=0;条件;i++){

        }
        1.变量初始化（只执行一次）
        2.判断循环条件，成立就进循环体，不成立就不循环
        3.进循环体
        4.设置下次循环的条件

        2->3->4  2->3->4 直到条件不成立。


        while (条件) {  
        
        }

        一般是不知道要循环多少次才使用while

        1.判断条件
        2.条件成立进循环体
        3.设置下次循环的条件

        for in循环
        通过枚举对象身上的属性名，来做到循环的目的
        循环的次数跟对象的属性的个数有关系
        只要是遍历对象的情况下，使用for in循环
        let arr = [1,2,3,4,5];
        for(let i in arr){
        console.log(arr[i]);
         }
什么时候用.什么时候用[]
        1.凡是能用点的地方都能用[]
        2.不过[]内要么是变量，要么是属性名（字符串）
        点只有属性名的时候才用
        switch(变量){
            case 2:(条件)
            console.log('语句1')
            break；（中断条件）
            default:(默认)
            break;
        }
        注意：break必须写，不然，当一个条件成立之后，还会执行下面的代码
        能用switch一定能用if，能用if不一定能用switch
字符串拼接：
        小技巧：
                先把设置一个默认值，然后咔咔加加
                '+  +' 

            注意:
                换行的时候使用字符串拼接


        ``(字符串模板)
            语法:
                `${放变量,放运算}`
            非空字符串的Boolean值是true，空字符串是false
Number    ''  []  0 null值为false   true 为1 其余分数字都为NaN
Boolean   NaN undefined null 空字符串  0 为false  其余都为true
          parseInt取整数，从数字起，非数字止
          parseFloat能取小数，从数字起，非数字止
          toFixed()括号内写几，保留几位小数  例子:num.toFixed(2)
前自增和后自增
          前自增，在找到变量之前就被处理过了，找到变量是被处理过后的变量
          后自增，在找到变量之前什么事儿都没发生，找到的变量就为非处理过的值
undefined的几种情况：
          1.变量定义未赋值
          2.对象没有某个属性的时候（对象没有属性是不会报错的）
          3.函数没有return值，默认为undefined
          4.函数的形参没有传实参
          5.简单类型的自定义属性
属性是obj.fn()方法是前面有.
null的几种情况：
          1.元素没有获取到
          2.在正则中搜索不到字符就会为null
          3.原型链的末端
delete obj.age;  //删除某个属性就用delete
        instanceof:
            左值是不是右值构造出来的，是就为true，否则false
            右值是不是左值的老爹

逻辑运算符：
             || 或者
                A || B
                1.在if中使用||如果A不成立那么会去找B,如果2个都不成立那么就为false
                2.从顺序上来来说，如果A成立就不会去B了,如果A不成立那么会去找B。

            && 并且
                A && B
                1.在if中使用 && 的含义 A要成立，B也要成立
                2.从顺序的角度上来说，A需要成立才会找B，如果A不成立就是A
三元（三目）运算符：  
            条件？执行1:执行2;
this的指向：
            window：
            1.直接在全局输出this
            2.函数打印this，并且直接调用
            3.定时器中的普通函数this为window
            4.匿名函数自执行
            事件中的this：
            那个事件触发，this就是那个对象
            实例：
            new构造函数-->this就是实例
            箭头函数：
            this就走定义箭头函数的域
            箭头函数不能new，一new就报错
            箭头函数没有arguments
            对象中的this
            let obj={function(){console.log(this)}}
自定义属性index
        当需要操作一个元素的时候去对应另一个元素（数据）
        那么就要想到索引（自定义属性）。
        <body>
    <button >按钮一</button>
    <button >按钮二</button>
    <button >按钮三</button>
    <div id="box"></div>
     <script>
       var i = 0;
      for(;i<3;i++){
        console.log(i);
        btns[i].zdy = i;
        // console.dir(btns[i])
        btns[i].onclick = function (){
            console.log(this.zdy);
        }
    }
 let 与 var 的区别
        1.let一个变量只能申明一次
        2.声明之后才能使用（有暂存死区）
        3.不做window映射
        4.支持块级作用域

    */</script>
</body>
</html>