<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>/*
    1.变量提升
    在代码执行之前，把其中带war和function关键字，先提前声明
    var只声明不定义；默认值为undefined
    function：声明加定义（函数内如果没有某个值可以去函数外找，如果函数外想取到函数内的值必须return）
    全局下：先看war 和function
    函数内部：先形参赋值，再看war和function
    条件句中：
    var 也会先声明
注意 ：function只声明不定义

    2.war和let区别
    war可以重复声名但let不行
    var可以变量提升但let不行
    var可以成为window属性，let不可以
    const声明一个常量；不能重新赋值

   2.全局作用域
   执行栈，在script标签内的第一层代码
   （1）如果当前script中的全局没有某个变量
    这个时候还会向上面的script中去查找（只会从向上找不会向下找），有就输出，没有就报错
    （2）如果有多个script标签，上面的script中的代码报错，是不会影响，下面script标签内的代码执行的
    （3）全局下的this为window
    （4）从作用域链的角度来说，最终会找到window下有没有某个属性（var的情况）
    （5）多个script标签如果都使用了let，那么同样走let特性（不能有重名变量）
    （6）使用war的时候等同于在window下注册了一个属性，并且在没赋值前为undefined
    不过在chrome|FF下 在变量的上方打印window的时候会有属性值结果，要注意的是，显示出来的是
     骗人的（跟undefined走）
     （7）函数默认是挂在window身上的
     （8）变量必须加var或者let来声明，不然在变量没赋值之前访问这个变量就报错
     3.私有作用域
     在函数执行栈中执行代码，函数中的变量和参数会默认处理在函数内部，不会被外界干扰
     如果函数内的计算或者逻辑处理需要被外界所接受，一般使用return
     4.块级作用域
     {}
     let 、const识别块级作用域
     var不识别
     要小心function(){}
五.作用域链
     1.当前域没有会去他的上级域去查找，直到window结束，window都没有会报错
     2.变量提升
     当代码在执行前会把var和function提前进行解析
     变量赋值为undefined，函数赋值为代码块
     3.执行上下文
     我只看等号赋值
     4.如果在函数中，参数赋值比执行上下文要提前（也可以理解，函数比正常执行多了一个参数赋值）
     5.赋值参数问题
     如果实参是简单类型，函数内再怎么搞都不会影响原值
     如果实参是引用类型，函数内直接改形参的值会影响原值
     但是如果在函数内赋值了一个新的对象，那么此时赋值之后再怎么改参数，都不会影响原值

box.属性有2种方式是可以直接获得到的
            1.设置了一个
                box.zdy = 0;
                console.log(box.zdy)

            2.元素对象默认的属性
                box.id

        在行间获取自定义属性
            ele.getAttribute('属性名')


        在行间设置自定义属性
            ele.setAttribute('属性名','属性值')

    
    
    
    
    
    
    
    
    
    */
    </script>
</body>
</html>